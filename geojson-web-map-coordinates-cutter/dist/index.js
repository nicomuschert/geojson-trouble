//# sourceMappingURL=./index.js.map
const{isArray:isArray}=Array,{ceil:ceil,round:round,abs:abs,min:min,max:max}=Math,MAX=Number.MAX_SAFE_INTEGER,MIN=Number.MIN_SAFE_INTEGER;export default class Cutter{constructor(t=!0,e=interpolate,i=isHole){this.applyCoordinateTranslation=t,this.interpolatorFn=e,this.isHoleFn=i}cut(t){return isArray(t)?this.cutPrimitive(t):"MultiPolygon"===t.type?this.cutPrimitive(t.coordinates):"GeometryCollection"===t.type?{type:"GeometryCollection",geometries:t.geometries.map(t=>this.cut(t))}:this.cutPrimitive(t)}cutPrimitive(t){let e,i;if(isArray(t))if(isArray(t[0]))if(isArray(t[0][0])){if(isArray(t[0][0][0]))return{type:"MultiPolygon",coordinates:t.reduce((t,e)=>{const i=this.cutPrimitive({type:"Polygon",coordinates:e});return[...t,..."Polygon"===i.type?[i.coordinates]:i.coordinates]},[])};e=isLineType(t)?"MultiLineString":"Polygon",i=t}else e=isLineType([t])?"LineString":"Polygon",i=[t];else e="Point",i=[[t]];else e=t.type,i="Point"===e?[[t.coordinates]]:"LineString"===e||"MultiPoint"===e?[t.coordinates]:t.coordinates;const n=this.cutRings(i,"Polygon"===e);if("LineString"===e){if(1===n[0].length)return{type:e,coordinates:n[0][0]};e="MultiLineString"}else if("Polygon"===e){if(1===n.length)return{type:e,coordinates:n[0]};e="MultiPolygon"}else{if("MultiPoint"===e){const t=n[0].map(t=>({type:"MultiPoint",coordinates:t}));return 1===t.length?t[0]:{type:"GeometryCollection",geometries:t}}if("Point"===e)return{type:"Point",coordinates:n[0][0][0]}}return"MultiLineString"===e?{type:e,coordinates:n.reduce((t,e)=>[...t,...e],[])}:{type:e,coordinates:n}}cutRings(t,e){const i=this.applyCoordinateTranslation,n=this.interpolatorFn,o=this.isHoleFn,r=t.map(()=>[]),s=t.map(()=>[]);for(let i=0;i<t.length;i++){const l=t[i],c=r[i],u=s[i];let p=[l[0].slice()],h=shiftOf(p[0][0]);u.push(h);for(let t=1;t<l.length;t++){const[e,i]=l[t],o=shiftOf(e);for(;h!==o;){const t=n((o>h?-180:180)-h,p[p.length-1],[e,i]);p.splice(p.length,0,...t),c.push(p),p=[p[p.length-1].slice()],u.push(h+=o>h?360:-360)}p.push([e,i])}if(0===c.length)c.push(p);else if(e){c[0].splice(0,0,...p),u.pop();for(let t=0;t<c.length;t++){const e=c[t],i=u[t];for(let n=1;n<c.length;n++)if(t!==n&&u[n]===i&&o(c[n],e)){const e=c[n];n<=t&&(t-=1),e.push(e[0].slice()),u.splice(n,1),c.splice(n,1),r.push([e]),s.push([i]);break}}t:for(let t=0;t<c.length;t++){const e=c[t],i=u[t],[n,o]=e[0],[r,s]=e[e.length-1];if(n!==r||o!==s||e.length<4){for(let r=t+1;r<c.length;r++){if(u[r]!==i)continue;e.splice(e.length,0,...c[r]),u.splice(r,1),c.splice(r,1);const[t,s]=e[e.length-1];if(n===t&&o===s)continue t}e.push([n,o])}}}else p.length>1&&c.push(p);for(let t=0;t<c.length;t++){const i=c[t];let n=i.length-(e?4:3);c[t]=i.filter(([t,e],o)=>!o||t!==i[o-1][0]||e!==i[o-1][1]||--n<0)}}if(e&&r[0]){const t=s.splice(1),e=r.splice(1),i=s[0].filter((t,e,i)=>i.indexOf(t)===e).reduce((i,n)=>{const l=e.reduce((e,i,o)=>[...e,...i.filter((e,i)=>t[o][i]===n)],[]);return i[n]=r[0].filter((t,e)=>s[0][e]===n).map((t,e,{length:i})=>{const n=[t];for(let e=0;e<l.length;e++)(1===i||o(l[e],t))&&n.push(l.splice(e--,1)[0]);return n}),i},{});r.splice(0,1,...s[0].map(t=>i[t].splice(0,1)[0])),s.splice(0,1,...s[0].map((t,e)=>r[e].map(e=>t)))}if(i)for(let t=0;t<r.length;t++){const e=r[t],i=s[t];for(let t=0;t<e.length;t++){const n=i[t];for(const i of e[t])i[0]+=n}r[t]=e.filter((t,e,i)=>{const n=t.join();for(;e&&++e<i.length;)if(i[e].join()===n)return!1;return!0})}return r}}const shiftOf=t=>{const e=(t/360*360-180)/360,i=ceil(e);return-360*(e===i&&i<0?i+1:i)},interpolate=(t,[e,i],[n,o])=>[[t,abs(e-n)<1e-9?i:round(1e9*(i+(o-i)/(n-e)*(t-e)))/1e9]],isLineType=t=>t.reduce((t,e)=>{if(t)return!0;const i=e[0],n=e[e.length-1];return e.length<4||i[0]!==n[0]||i[1]!==n[1]},!1),isHole=(t,e)=>{const[i,n,o,r]=bbox(t),[s,l,c,u]=bbox(e);return i>=s&&o<=c&&n>=l&&r<=u},bbox=t=>t.reduce(([t,e,i,n],[o,r])=>[min(t,o),min(e,r),max(i,o),max(n,r)],[MAX,MAX,MIN,MIN]);